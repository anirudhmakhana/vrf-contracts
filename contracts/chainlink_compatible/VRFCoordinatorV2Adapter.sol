// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import {VRFCoordinatorV2Stub} from "./internal/VRFCoordinatorV2Stub.sol";
import {GelatoVRFConsumer} from "contracts/Consumer.sol";
import {
    VRFConsumerBaseV2
} from "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

/// @title VRFCoordinatorV2Adapter
/// @dev This contract acts as an adapter between Gelato and Chainlink VRF.
/// It allows Gelato to make VRF randomness requests using Chainlink's VRF Coordinator V2 contract.
contract VRFCoordinatorV2Adapter is VRFCoordinatorV2Stub, GelatoVRFConsumer {
    /// @dev Emitted when an attempt is made to request randomness with zero minimum confirmations.
    error ZeroConfirmationsRequested();

    uint256 private _requestIdCounter = 1;
    address private immutable _operator;

    /// @dev Constructor to initialize the operator address.
    constructor(address operator) {
        _operator = operator;
    }

    /// @notice Request VRF randomness using Chainlink's VRF Coordinator V2.
    /// @param minimumRequestConfirmations Minimum confirmations required for the request.
    /// @param numWords Number of random words to generate.
    /// @return requestId The unique identifier for the request.
    function requestRandomWords(
        bytes32 /*keyHash*/,
        uint64 /*subId*/,
        uint16 minimumRequestConfirmations,
        uint32 /*callbackGasLimit*/,
        uint32 numWords
    ) external override returns (uint256 requestId) {
        return
            _requestRandomWords(
                minimumRequestConfirmations,
                numWords,
                VRFConsumerBaseV2(msg.sender)
            );
    }

    /// @notice Request VRF randomness for a specific consumer.
    /// @param minimumRequestConfirmations Minimum confirmations required for the request.
    /// @param numWords Number of random words to generate.
    /// @param consumer The VRFConsumerBaseV2 contract to receive the randomness callback.
    /// @return requestId The unique identifier for the request.
    function requestRandomWordsForConsumer(
        bytes32 /*keyHash*/,
        uint64 /*subId*/,
        uint16 minimumRequestConfirmations,
        uint32 /*callbackGasLimit*/,
        uint32 numWords,
        VRFConsumerBaseV2 consumer
    ) external returns (uint256 requestId) {
        return
            _requestRandomWords(
                minimumRequestConfirmations,
                numWords,
                consumer
            );
    }

    /// @notice Internal function to request VRF randomness and emit the request event.
    /// @dev This function is used to handle randomness requests and emit the appropriate event.
    /// @param minimumRequestConfirmations Minimum confirmations required for the request.
    /// @param numWords Number of random words to generate.
    /// @param consumer The VRFConsumerBaseV2 contract to receive the randomness callback.
    /// @return requestId The unique identifier for the request.
    function _requestRandomWords(
        uint16 minimumRequestConfirmations,
        uint32 numWords,
        VRFConsumerBaseV2 consumer
    ) private returns (uint256 requestId) {
        // Ensure minimum request confirmations is not zero
        if (minimumRequestConfirmations == 0) {
            revert ZeroConfirmationsRequested();
        }

        // Increment the requestId counter and emit the randomness request event
        requestId = _requestIdCounter++;
        emit RequestedRandomness(abi.encode(numWords, requestId, consumer));
        return requestId;
    }

    /// @notice Callback function used by Gelato VRF to return the random number.
    /// @param randomness The random number generated by Gelato VRF.
    /// @param data Additional data provided by Gelato VRF, typically containing request details.
    function fulfillRandomness(
        uint256 randomness,
        bytes calldata data
    ) external {
        require(msg.sender == _operator);
        (uint32 numWords, uint256 requestId, VRFConsumerBaseV2 consumer) = abi
            .decode(data, (uint32, uint256, VRFConsumerBaseV2));
        bytes32 seed = keccak256(
            abi.encode(randomness, address(this), block.chainid, requestId)
        );
        uint[] memory words = new uint[](numWords);
        for (uint32 i = 0; i < numWords; i++) {
            words[i] = uint(keccak256(abi.encode(seed, i)));
        }
        consumer.rawFulfillRandomWords(requestId, words);
    }
}
